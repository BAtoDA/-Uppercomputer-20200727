<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="uiRichTextBox1.Text" xml:space="preserve">
    <value>■  常数

常数是一个可以被各式语句直接使用的固定的资料。有如下格式：

常数类型 ; 举例 ; 使用说明

．十进制整数 ; 345, -234, 0, 23456

．十六进制数 ; 0x3b, 0xffff, ; 必须以 0x 开头

．字符型 ; ‘a’, ‘data’, ‘函数名称’ ; 字符必须使用单引号

．布尔型 ; true, false

下面即为一个简单的常数使用的范例。

macro_command main()

short A, B  // 声明 A 和 B 为短整型变数

A = 1234

B = 0x12  // 1234 和 0x12 即为常数

end macro_command

 

■  变数

变量是一个代表着各种资料的名称。在宏指令中，这些资料可以随着宏指令语句执行的结果改变而改变。

变量的命名规则:

．必须以英文字母开头。

．变量名称长度不超过 32 个字符。

．系统保留缓存器名称不能作为变量名称。

下面为 8 种不同的变量类型，前 5 种为有号数值型态，后 3 种为无号数值型态：

变量类型 ; 描述 ; 范围

．Bool 布尔型 ; 1 bit (一个位) ; 0, 1

．Char 字符型 ; 8 bits (一个字节) ; ±127

．Short 短整型 ; 16 bits (一个字符) ; ±32767

．Int 双整型 ; 32 bits (双字符) ; ±2147418112

．Float 浮点型 ; 32 bits (双字符)

．Unsigned Char 字符型 ; 8 bits (一个字节) ; 0 ~ 255

．Unsigned Short 短整型 ; 16 bits (一个字符) ; 0 ~ 65535

．Unsigned Int 双整型 ; 32 bits (双字符) ; 0 ~ 4,294,967,295

变数声明

变量必须在使用前声明。所以在宏指令中，所有的变量都必须在语句使用前都被声明完成。声明变量时，先定义变量的类型，后面再跟着变量名称。

 

数组声明

宏指令支持一维数组 (下标从0开始)。声明数组变量时，先定义数组变量的类型，变量名称，接着就是该数组变量的个数，变量个数必须放置在 “[]” 符号中。数组变量的长度为 1 ~ 4096。一个宏指令中只支持 4096 个变量。

如下范例:

int a[10]

short b[20], switch[30]

float pressure[15]

数组的下标最小为 0，最大下标为 (数组的长度 - 1)

如下范例:

char data[100]  // 数组变量的长度是 100

所以: 最小的数组为 “data[0]”，最大的数组为 “data[99]”，即 100 - 1 = 99。

 

变量和数组初始化

有两种方法可以让变量初始化：

．使用语句中的赋值语句 (=)

如下范例:

int a

float b[3]

a = 10

b[0] = 1

．声明变量时直接赋值

char a = '5', b = 9

数组变量的声明是一个特殊的情况。一个完整的数组被初始化时，可以在数组变量声明时，将数据放置在波形括号 “{}” 里面，各数据使用逗号分开。

如下范例:

float data[4] = {11, 22, 33, 44}  // 这样 data[0] = 11, data[1] = 22….

关于进制转换问题
10进制转换成16进制 接收类型必须为String类型
 string v = Convert.ToInt32(10).ToString("X");
这里的10是你需要转换的数值 X表示不带0X前缀
16进制转换成10进制 接收类型比较位Int类型
 int v = Convert.ToInt32("A",16);</value>
  </data>
</root>